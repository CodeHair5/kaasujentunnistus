<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Kuplintaefekti - Kamera Yläviistoon</title>
    <style>
        body { margin: 0; background-color: #111; color: #eee; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.7); z-index: 10; }
        #start-button { padding: 15px 30px; font-size: 24px; cursor: pointer; border: 2px solid white; background-color: transparent; color: white; border-radius: 5px; }
        #controls { position: absolute; top: 10px; left: 10px; padding: 10px; background: rgba(0, 0, 0, 0.5); border-radius: 5px; display: flex; align-items: center; }
        button { margin-left: 10px; }
        #instructions { position: absolute; top: 10px; width: 100%; text-align: center; font-size: 16px; color: #eee; pointer-events: none; }
    </style>
</head>
<body>
    <div id="overlay"><button id="start-button">Aloita simulaatio</button></div>
    <div id="instructions"><p>Sytytä tulitikku ja klikkaa sen jälkeen koeputkea.</p></div>
    <div id="controls">
        <button id="light-match-button">Sytytä tulitikku</button>
        <button id="reset-button">Aloita alusta</button>
    </div>
    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- Perusasetukset ja scenen luonti ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        const controls = new OrbitControls(camera, renderer.domElement);
        const clock = new THREE.Clock();
        
        // --- Globaalit muuttujat ---
        let bubbles = [], flameParticles = [], smokeParticles = [];
        const testTubes = [], clickableObjects = [];
        const raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
        let matchstick, matchstickHead, isMatchLit = false, flameIntensity = 1.0;
        let matchstickTargetPosition = null;
        const MATCHSTICK_START_POS = new THREE.Vector3(-4, 5, 0);
        let simulationStarted = false;
        let audioListener, matchStrikeSound, oxygenSound, hydrogenSound;

        // --- Materiaalit ---
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0.1, roughness: 0.05, ior: 1.5,
            transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false
        });
        const liquidMaterial = new THREE.MeshPhysicalMaterial({ metalness: 0, roughness: 0.1, ior: 1.33, transmission: 0.9, color: 0x88ddff, transparent: true, thickness: 0.2, depthWrite: true, emissive: 0x112233 });
        const bubbleMaterial = new THREE.MeshPhysicalMaterial({ color: 0xcccccc, metalness: 0.1, roughness: 0.5 });
        const flameMaterials = [ new THREE.MeshBasicMaterial({ color: 0xffd000, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }), new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }) ];
        const smokeMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5, blending: THREE.NormalBlending, depthWrite: false });

        // --- Alustusfunktio ---
        function init() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);
            
            // MUUTETTU: Nostettu kameran katselukohtaa (target) ja kameran omaa Y-positiota
            controls.target.set(0, 2.0, 0); // Esim. 2.0 sijaan 1.5
            camera.position.y = 2.5;         // Nostettu kameran korkeutta
            
            new RGBELoader().load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
                scene.background = new THREE.Color(0x111111);
                renderer.render(scene, camera);
            });

            createTestTube(new THREE.Vector3(-2.0, 1.5, 0), 0.25, 'co2');
            createTestTube(new THREE.Vector3(0, 1.5, 0), 0.25, 'o2');
            createTestTube(new THREE.Vector3(2.0, 1.5, 0), 0.25, 'h2');
            createMatchstick();
            
            initAudio();
            updateCamera(); // Tämä asettaa Z-position, mutta Y-position ja target ovat jo asetettu
        }

        // --- Responsiivinen kameralogiikka ---
        function updateCamera() {
            const contentWidth = 9; 
            const contentHeight = 6;
            camera.aspect = window.innerWidth / window.innerHeight;
            const fov = camera.fov * (Math.PI / 180);
            const distHeight = (contentHeight / 2) / Math.tan(fov / 2);
            const distWidth = (contentWidth / 2) / (Math.tan(fov / 2) * camera.aspect);
            const distance = Math.max(distHeight, distWidth);
            camera.position.z = distance * 1.2;
            camera.updateProjectionMatrix();
        }

        // --- Äänien alustus ---
        function initAudio() {
            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
            const audioLoader = new THREE.AudioLoader();
            
            matchStrikeSound = new THREE.Audio(audioListener);
            audioLoader.load('tulitikku.mp3', (buffer) => { matchStrikeSound.setBuffer(buffer); });
            
            oxygenSound = new THREE.Audio(audioListener);
            audioLoader.load('happi.mp3', (buffer) => { 
                oxygenSound.setBuffer(buffer);
                oxygenSound.setLoop(true);
            });
            
            hydrogenSound = new THREE.Audio(audioListener);
            audioLoader.load('vety.mp3', (buffer) => { hydrogenSound.setBuffer(buffer); });
        }

        // --- Scenen rakennus ja partikkelit ---
        function createTestTube(position, liquidLevel, id) {
            const group = new THREE.Group();
            const radius = 0.5, tubeHeight = 3.0, wallThickness = 0.05;
            const glassGeom = BufferGeometryUtils.mergeGeometries([ new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2).rotateX(Math.PI), new THREE.CylinderGeometry(radius, radius, tubeHeight, 32, 1, true).translate(0, tubeHeight / 2, 0) ]);
            const glassMesh = new THREE.Mesh(glassGeom, glassMaterial.clone());
            glassMesh.renderOrder = 2;
            group.add(glassMesh);
            const liquidRadius = radius - wallThickness;
            const liquidTubeHeight = tubeHeight * liquidLevel;
            const liquidGeom = BufferGeometryUtils.mergeGeometries([ new THREE.SphereGeometry(liquidRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2).rotateX(Math.PI), new THREE.CylinderGeometry(liquidRadius, liquidRadius, liquidTubeHeight, 32).translate(0, liquidTubeHeight / 2, 0) ]);
            const liquidMesh = new THREE.Mesh(liquidGeom, liquidMaterial.clone());
            liquidMesh.geometry.computeBoundingBox();
            liquidMesh.renderOrder = 1;
            group.add(liquidMesh);
            group.position.copy(position);
            scene.add(group);
            testTubes.push({ id, group, glassMesh, liquidBounds: liquidMesh.geometry.boundingBox, liquidRadius, reactionTriggered: false });
            clickableObjects.push(glassMesh);
        }
        function createMatchstick() {
            matchstick = new THREE.Group();
            matchstickHead = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshStandardMaterial({ color: 0x8B0000 }));
            matchstickHead.position.y = 1.25;
            matchstick.add(new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8), new THREE.MeshStandardMaterial({ color: 0xdeb887 })), matchstickHead);
            matchstick.rotation.x = -Math.PI / 3;
            matchstick.position.copy(MATCHSTICK_START_POS);
            scene.add(matchstick);
        }
        function createBubble(tubeData){const b=new THREE.Mesh(new THREE.SphereGeometry(Math.random()*.04+.02,8,8),bubbleMaterial);const a=Math.random()*Math.PI*2;const r=Math.random()*tubeData.liquidRadius*.9;b.position.set(tubeData.group.position.x+Math.cos(a)*r,tubeData.group.position.y+tubeData.liquidBounds.min.y+b.geometry.parameters.radius,tubeData.group.position.z+Math.sin(a)*r);b.userData.velocityY=Math.random()*.02+.01;b.userData.surfaceY=tubeData.group.position.y+tubeData.liquidBounds.max.y;bubbles.push(b);scene.add(b);}
        function createFlameParticle(origin){const p=new THREE.Mesh(new THREE.SphereGeometry(Math.random()*.1*flameIntensity+.1,8,8),flameMaterials[Math.floor(Math.random()*flameMaterials.length)]);p.position.copy(origin);p.userData.velocity=new THREE.Vector3((Math.random()-.5)*.02,(Math.random()*.03+.04)*flameIntensity,(Math.random()-.5)*.02);p.userData.initialLifespan=Math.random()*.6+.4;p.userData.lifespan=p.userData.initialLifespan;flameParticles.push(p);scene.add(p);}
        function createSmokeParticle(origin){const p=new THREE.Mesh(new THREE.SphereGeometry(.05,8,8),smokeMaterial.clone());p.position.copy(origin);p.userData.velocity=new THREE.Vector3((Math.random()-.5)*.01,Math.random()*.02+.01,(Math.random()-.5)*.01);p.userData.lifespan=Math.random()*1+.5;smokeParticles.push(p);scene.add(p);}
        function createExplosion(origin) {
            if (hydrogenSound) hydrogenSound.play();
            for(let i = 0; i < 150; i++){
                const particleSize = Math.random() * 0.15 + 0.05;
                const particle = new THREE.Mesh(new THREE.SphereGeometry(particleSize, 8, 8), flameMaterials[Math.floor(Math.random() * flameMaterials.length)]);
                particle.position.copy(origin);
                particle.userData.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(Math.random() * 1.5 + 0.5);
                particle.userData.lifespan = Math.random() * 0.5 + 0.3;
                particle.userData.initialLifespan = particle.userData.lifespan;
                flameParticles.push(particle);
                scene.add(particle);
            }
        }

        // --- Ohjauslogiikka ---
        document.getElementById('start-button').addEventListener('click', () => {
            if (audioListener.context.state === 'suspended') { audioListener.context.resume(); }
            document.getElementById('overlay').style.display = 'none';
            renderer.compile(scene, camera);
            simulationStarted = true;
            animate();
        }, { once: true });
        document.getElementById('light-match-button').addEventListener('click', () => { 
            if (simulationStarted) { isMatchLit = true; if (matchStrikeSound && !matchStrikeSound.isPlaying) { matchStrikeSound.play(); } }
        });
        document.getElementById('reset-button').addEventListener('click', () => { if (simulationStarted) resetSimulation(); });
        window.addEventListener('click', (event) => {
            if (!simulationStarted || event.target.tagName === 'BUTTON') return;
            mouse.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1);
            raycaster.setFromCamera(mouse, camera);
            const intersect = raycaster.intersectObjects(clickableObjects)[0];
            if (intersect) {
                const tubeGroup = intersect.object.parent;
                const targetForHead = new THREE.Vector3(tubeGroup.position.x, tubeGroup.position.y + 3.2, tubeGroup.position.z + 0.2);
                matchstickTargetPosition = targetForHead.clone().sub(new THREE.Vector3(0, 1.25, 0).applyEuler(matchstick.rotation));
            }
        });

        function resetSimulation() {
            isMatchLit = false;
            [...bubbles, ...flameParticles, ...smokeParticles].forEach(p => scene.remove(p));
            bubbles = []; flameParticles = []; smokeParticles = [];
            testTubes.forEach(t => { 
                t.reactionTriggered = false; 
                t.glassMesh.material.opacity = glassMaterial.opacity;
            });
            matchstick.position.copy(MATCHSTICK_START_POS);
            matchstickTargetPosition = null;
            if (oxygenSound && oxygenSound.isPlaying) oxygenSound.stop();
            
            // MUUTETTU: Palautetaan kameran target ja y-positio myös resetissä
            controls.target.set(0, 2.0, 0); // Sama kuin initissä
            camera.position.y = 2.5;         // Sama kuin initissä
            
            updateCamera();
            controls.update(); // Päivitetään ohjaimet muutosten jälkeen
        }

        // --- Animaatiolooppi ---
        const flameOrigin = new THREE.Vector3();
        function animate() {
            requestAnimationFrame(animate);
            if (!simulationStarted) return;
            const deltaTime = clock.getDelta();

            if (Math.random() < 0.25) {createBubble(testTubes[Math.floor(Math.random() * testTubes.length)]);}
            for (let i = bubbles.length - 1; i >= 0; i--) {const b=bubbles[i];b.position.y+=b.userData.velocityY;if(b.position.y>b.userData.surfaceY){scene.remove(b);bubbles.splice(i,1);}}
            if (matchstickTargetPosition) {matchstick.position.lerp(matchstickTargetPosition,.05);if(matchstick.position.distanceTo(matchstickTargetPosition)<.01){matchstickTargetPosition=null;}}
            
            matchstickHead.getWorldPosition(flameOrigin);
            flameIntensity = 1.0;

            if (isMatchLit) {
                let matchIsInO2Zone = false;

                for (const tube of testTubes) {
                    const tubeTopPos = new THREE.Vector3(tube.group.position.x, tube.group.position.y + 3.0, tube.group.position.z);
                    const distance = flameOrigin.distanceTo(tubeTopPos);

                    if (tube.id === 'o2' && distance < 0.6) {
                        flameIntensity = 3.0; 
                        matchIsInO2Zone = true;
                    }

                    if (distance < 0.6 && !tube.reactionTriggered) {
                        if (tube.id === 'co2') { 
                            isMatchLit = false; 
                            for(let i=0; i<20; i++) createSmokeParticle(flameOrigin); 
                            tube.reactionTriggered = true;
                        }
                        if (tube.id === 'h2') {
                            isMatchLit = false;
                            createExplosion(tubeTopPos);
                            tube.glassMesh.material.opacity = 0.8;
                            tube.reactionTriggered = true;
                            for(let i=0; i<20; i++) createSmokeParticle(flameOrigin);
                        }
                    }
                }

                if (oxygenSound) {
                    if (matchIsInO2Zone && !oxygenSound.isPlaying) {
                        oxygenSound.play();
                    } else if (!matchIsInO2Zone && oxygenSound.isPlaying) {
                        oxygenSound.stop();
                    }
                }
                
                if (Math.random() < 0.6) { createFlameParticle(flameOrigin); }
            } else {
                 if (oxygenSound && oxygenSound.isPlaying) {
                    oxygenSound.stop();
                }
            }
            
            for (let i = flameParticles.length - 1; i >= 0; i--) {const p=flameParticles[i];p.userData.lifespan-=deltaTime;if(p.userData.lifespan<=0){scene.remove(p);flameParticles.splice(i,1);}else{p.position.add(p.userData.velocity);const l=p.userData.lifespan/p.userData.initialLifespan;p.scale.setScalar(l*flameIntensity);}}
            for (let i = smokeParticles.length - 1; i >= 0; i--) {const p=smokeParticles[i];p.userData.lifespan-=deltaTime;if(p.userData.lifespan<=0){scene.remove(p);smokeParticles.splice(i,1);}else{p.position.add(p.userData.velocity);p.material.opacity=p.userData.lifespan/1.5;}}

            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            updateCamera();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>