<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Kuplintaefekti</title>
    <style>
        body { margin: 0; background-color: #f0f0f0; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        #instructions-container {
            position: absolute;
            top: 10px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
        #controls-container {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        #controls {
            padding: 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }
        button { margin-left: 10px; }
        #instructions {
            font-size: 16px;
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 5px;
        }
    </style>
    <!-- Lisätty Tone.js-äänikirjasto -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
</head>
<body>
    <div id="instructions-container">
        <div id="instructions">
            <p>Sytytä tulitikku ja klikkaa sen jälkeen koeputkea. Mitä kaasuja koeputkista vapautuu?</p>
        </div>
    </div>

    <div id="controls-container">
        <div id="controls">
            <button id="light-match-button">Sytytä tulitikku</button>
            <button id="reset-button">Aloita alusta</button>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // 1. Basic Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const INITIAL_CAMERA_POS = new THREE.Vector3(0, 4, 10);
        camera.position.copy(INITIAL_CAMERA_POS);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);
        const controls = new OrbitControls(camera, renderer.domElement);
        const INITIAL_CONTROLS_TARGET = new THREE.Vector3(0, 1.5, 0);
        controls.target.copy(INITIAL_CONTROLS_TARGET);
        
        // 2. Lighting
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_03_1k.hdr', (texture) => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = texture;
            scene.background = new THREE.Color(0xf0f0f0);
        });

        // 3. Materials
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0, roughness: 0.05, ior: 1.5, transmission: 1.0,
            thickness: 0.01, transparent: true, side: THREE.DoubleSide, depthWrite: false
        });
        const frostedGlassMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xffffff, metalness: 0, roughness: 0.8, ior: 1.5, transmission: 1.0,
            thickness: 0.1, transparent: true, side: THREE.DoubleSide, depthWrite: false
        });
        const liquidMaterial = new THREE.MeshPhysicalMaterial({
            metalness: 0, roughness: 0.1, ior: 1.33, transmission: 1.0,
            color: 0xADD8E6, transparent: true, thickness: 0.2, depthWrite: true
        });
        const bubbleMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x555555, metalness: 0.1, roughness: 0.5, transparent: false
        });
        const flameMaterials = [
            new THREE.MeshBasicMaterial({ color: 0xffd000, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false }),
            new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false })
        ];
        const smokeMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.5, blending: THREE.NormalBlending, depthWrite: false });

        // 4. Global variables
        let bubbles = [], activeFlameParticles = [], activeSmokeParticles = [];
        const testTubes = [];
        const clickableObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let matchstick, matchstickHead;
        let isMatchLit = false;
        let flameIntensity = 1.0;
        const clock = new THREE.Clock();
        let matchstickTargetPosition = null;
        const MATCHSTICK_START_POS = new THREE.Vector3(-4, 5, 0);
        
        let explosionSynth, matchStrikeSynth, oxygenFlameSynth;
        let isOxygenSoundPlaying = false;
        
        const flameParticlePool = [];
        const smokeParticlePool = [];

        // 5. Helper function to create a test tube
        function createTestTube(position, liquidLevel, id) {
            const group = new THREE.Group();
            const radius = 0.5;
            const tubeHeight = 3.0;
            const wallThickness = 0.05;

            const bottomGeometry = new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            bottomGeometry.rotateX(Math.PI);
            const tubeGeometry = new THREE.CylinderGeometry(radius, radius, tubeHeight, 32, 1, true);
            tubeGeometry.translate(0, tubeHeight / 2, 0);
            const mergedGlassGeom = BufferGeometryUtils.mergeGeometries([bottomGeometry, tubeGeometry]);
            const glassMesh = new THREE.Mesh(mergedGlassGeom, glassMaterial.clone());
            glassMesh.renderOrder = 3;
            group.add(glassMesh);
            
            const liquidRadius = radius - wallThickness;
            const liquidTubeHeight = tubeHeight * liquidLevel;
            const liquidBottomGeom = new THREE.SphereGeometry(liquidRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            liquidBottomGeom.rotateX(Math.PI);
            const liquidTubeGeom = new THREE.CylinderGeometry(liquidRadius, liquidRadius, liquidTubeHeight, 32);
            liquidTubeGeom.translate(0, liquidTubeHeight / 2, 0);
            const mergedLiquidGeom = BufferGeometryUtils.mergeGeometries([liquidBottomGeom, liquidTubeGeom]);
            mergedLiquidGeom.computeBoundingBox();
            const liquidMesh = new THREE.Mesh(mergedLiquidGeom, liquidMaterial.clone());
            liquidMesh.renderOrder = 2;
            group.add(liquidMesh);
            
            group.position.copy(position);
            scene.add(group);

            const tubeData = {
                id: id, group: group, glassMesh: glassMesh,
                liquidBounds: liquidMesh.geometry.boundingBox,
                liquidRadius: liquidRadius, reactionTriggered: false
            };
            testTubes.push(tubeData);
            clickableObjects.push(glassMesh);
            return group;
        }
        
        function createMatchstick() {
            matchstick = new THREE.Group();
            const stickGeom = new THREE.CylinderGeometry(0.05, 0.05, 2.5, 8);
            const stickMat = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
            const stick = new THREE.Mesh(stickGeom, stickMat);
            const headGeom = new THREE.SphereGeometry(0.1, 16, 16);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            matchstickHead = new THREE.Mesh(headGeom, headMat);
            matchstickHead.position.y = 1.25;
            matchstick.add(stick);
            matchstick.add(matchstickHead);
            matchstick.rotation.x = -Math.PI / 3;
            matchstick.position.copy(MATCHSTICK_START_POS);
            scene.add(matchstick);
        }

        // 6. Create initial scene
        createTestTube(new THREE.Vector3(-2.0, 1.5, 0), 0.25, 'co2');
        createTestTube(new THREE.Vector3(0, 1.5, 0), 0.25, 'o2');
        createTestTube(new THREE.Vector3(2.0, 1.5, 0), 0.25, 'h2');
        createMatchstick();

        function initPools() {
            for (let i = 0; i < 200; i++) {
                const particleGeom = new THREE.SphereGeometry(1, 8, 8);
                const flameParticle = new THREE.Mesh(particleGeom, flameMaterials[0]);
                flameParticle.visible = false;
                flameParticlePool.push(flameParticle);
                scene.add(flameParticle);

                const smokeParticle = new THREE.Mesh(particleGeom, smokeMaterial);
                smokeParticle.visible = false;
                smokeParticlePool.push(smokeParticle);
                scene.add(smokeParticle);
            }
        }
        initPools();

        // 7. Particle Logic
        function createBubble(tubeData) {
            const bubbleSize = Math.random() * 0.04 + 0.02;
            const bubbleGeom = new THREE.SphereGeometry(bubbleSize, 8, 8);
            const bubble = new THREE.Mesh(bubbleGeom, bubbleMaterial);
            const angle = Math.random() * Math.PI * 2;
            const spawnRadius = Math.random() * tubeData.liquidRadius * 0.9;
            const x = Math.cos(angle) * spawnRadius;
            const z = Math.sin(angle) * spawnRadius;
            const liquidBottomY = tubeData.group.position.y + tubeData.liquidBounds.min.y;
            bubble.position.set(tubeData.group.position.x + x, liquidBottomY + bubbleSize, tubeData.group.position.z + z);
            bubble.userData.velocityY = Math.random() * 0.02 + 0.01;
            bubble.userData.surfaceY = tubeData.group.position.y + tubeData.liquidBounds.max.y;
            bubbles.push(bubble);
            scene.add(bubble);
        }

        function getFromPool(pool) {
            const particle = pool.find(p => !p.visible);
            return particle;
        }

        function createFlameParticle(origin) {
            const particle = getFromPool(flameParticlePool);
            if (!particle) return;

            particle.material = flameMaterials[Math.floor(Math.random() * flameMaterials.length)];
            const particleSize = Math.random() * 0.1 * flameIntensity + 0.1;
            particle.userData.initialSize = particleSize;
            particle.scale.setScalar(particleSize);
            particle.position.copy(origin);
            particle.userData.velocity = new THREE.Vector3( (Math.random() - 0.5) * 0.02, (Math.random() * 0.03 + 0.04) * flameIntensity, (Math.random() - 0.5) * 0.02);
            particle.userData.initialLifespan = Math.random() * 0.6 + 0.4;
            particle.userData.lifespan = particle.userData.initialLifespan;
            particle.visible = true;
            activeFlameParticles.push(particle);
        }

        function createSmokeParticle(origin) {
            const particle = getFromPool(smokeParticlePool);
            if (!particle) return;

            particle.scale.setScalar(0.05);
            particle.position.copy(origin);
            particle.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.01, Math.random() * 0.02 + 0.01, (Math.random() - 0.5) * 0.01);
            particle.userData.lifespan = Math.random() * 1.0 + 0.5;
            particle.visible = true;
            activeSmokeParticles.push(particle);
        }
        
        function createExplosion(origin) {
            if (explosionSynth) {
                explosionSynth.triggerAttackRelease("8n");
            }

            const explosionLight = new THREE.PointLight(0xffd580, 50, 15);
            explosionLight.position.copy(origin);
            scene.add(explosionLight);
            setTimeout(() => scene.remove(explosionLight), 200);

            for (let i = 0; i < 150; i++) {
                const particle = getFromPool(flameParticlePool);
                if (!particle) continue;

                particle.material = flameMaterials[Math.floor(Math.random() * flameMaterials.length)];
                const particleSize = Math.random() * 0.15 + 0.05;
                particle.userData.initialSize = particleSize;
                particle.scale.setScalar(particleSize);
                particle.position.copy(origin);
                particle.userData.velocity = new THREE.Vector3((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5)).normalize().multiplyScalar(Math.random() * 0.4 + 0.1);
                particle.userData.lifespan = Math.random() * 0.4 + 0.2;
                particle.userData.initialLifespan = particle.userData.lifespan;
                particle.visible = true;
                activeFlameParticles.push(particle);
            }
        }

        // 8. Control Logic
        document.getElementById('light-match-button').addEventListener('click', () => {
             if (!isMatchLit && matchStrikeSynth) {
                matchStrikeSynth.triggerAttackRelease("16n");
            }
            isMatchLit = true;
        });
        document.getElementById('reset-button').addEventListener('click', resetSimulation);

        let audioStarted = false;
        function initAudio() {
            if (audioStarted) return;
            Tone.start();
            explosionSynth = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0 } }).toDestination();
            matchStrikeSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 } }).toDestination();
            oxygenFlameSynth = new Tone.NoiseSynth({ noise: { type: 'pink', playbackRate: 0.5 }, volume: -20, envelope: { attack: 0.1, decay: 0.2, sustain: 1.0 } }).toDestination();
            explosionSynth.triggerAttackRelease("32n", "+0.1", 0);
            matchStrikeSynth.triggerAttackRelease("32n", "+0.1", 0);
            audioStarted = true;
        }
        window.addEventListener('click', initAudio, { once: true });


        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(clickableObjects);
            if (intersects.length > 0) {
                const clickedTubeGroup = intersects[0].object.parent;
                const TUBE_TOP_Y = clickedTubeGroup.position.y + 3.2; 
                
                const targetForHead = new THREE.Vector3(clickedTubeGroup.position.x, TUBE_TOP_Y, clickedTubeGroup.position.z + 0.2);
                const headLocalOffset = new THREE.Vector3(0, 1.25, 0);
                const rotatedOffset = headLocalOffset.clone().applyEuler(matchstick.rotation);
                
                matchstickTargetPosition = targetForHead.clone().sub(rotatedOffset);
            }
        });

        function resetSimulation() {
            isMatchLit = false;
            if (isOxygenSoundPlaying && oxygenFlameSynth) {
                oxygenFlameSynth.triggerRelease();
                isOxygenSoundPlaying = false;
            }
            bubbles.forEach(b => scene.remove(b));
            activeFlameParticles.forEach(p => p.visible = false);
            activeSmokeParticles.forEach(p => p.visible = false);
            bubbles = []; activeFlameParticles = []; activeSmokeParticles = [];
            testTubes.forEach(tube => {
                tube.reactionTriggered = false;
                tube.glassMesh.material = glassMaterial;
            });
            matchstickTargetPosition = MATCHSTICK_START_POS;

            camera.position.copy(INITIAL_CAMERA_POS);
            controls.target.copy(INITIAL_CONTROLS_TARGET);
            controls.update();
        }

        // 9. Animation Loop
        const flameOrigin = new THREE.Vector3();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            if (Math.random() < 0.25) {
                const randomTubeIndex = Math.floor(Math.random() * testTubes.length);
                createBubble(testTubes[randomTubeIndex]);
            }
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const bubble = bubbles[i];
                bubble.position.y += bubble.userData.velocityY;
                if (bubble.position.y > bubble.userData.surfaceY) {
                    scene.remove(bubble);
                    bubbles.splice(i, 1);
                }
            }

            if (matchstickTargetPosition) {
                matchstick.position.lerp(matchstickTargetPosition, 0.05);
                if (matchstick.position.distanceTo(matchstickTargetPosition) < 0.01) {
                    matchstickTargetPosition = null;
                }
            }

            matchstickHead.getWorldPosition(flameOrigin);
            flameIntensity = 1.0;
            let isOverOxygenTube = false;
            
            if (isMatchLit) {
                for (const tube of testTubes) {
                    const tubeTopPos = new THREE.Vector3(tube.group.position.x, tube.group.position.y + 3.0, tube.group.position.z);
                    const distance = flameOrigin.distanceTo(tubeTopPos);

                    if (distance < 0.6 && !tube.reactionTriggered) {
                        if (tube.id === 'co2') {
                            isMatchLit = false;
                            for(let i=0; i<20; i++) createSmokeParticle(flameOrigin);
                        }
                        if (tube.id === 'o2') {
                            flameIntensity = 3.0;
                            isOverOxygenTube = true;
                        }
                        if (tube.id === 'h2') {
                            isMatchLit = false;
                            createExplosion(tubeTopPos);
                            tube.glassMesh.material = frostedGlassMaterial;
                            for(let i=0; i<20; i++) createSmokeParticle(flameOrigin);
                            tube.reactionTriggered = true;
                        }
                    }
                }

                if (Math.random() < 0.6) { 
                    createFlameParticle(flameOrigin);
                }
            }
            
            if (oxygenFlameSynth) {
                if (isOverOxygenTube && !isOxygenSoundPlaying) {
                    oxygenFlameSynth.triggerAttack();
                    isOxygenSoundPlaying = true;
                } else if (!isOverOxygenTube && isOxygenSoundPlaying) {
                    oxygenFlameSynth.triggerRelease();
                    isOxygenSoundPlaying = false;
                }
            }

            for (let i = activeFlameParticles.length - 1; i >= 0; i--) {
                const particle = activeFlameParticles[i];
                particle.userData.lifespan -= deltaTime;
                if (particle.userData.lifespan <= 0) {
                    particle.visible = false;
                    activeFlameParticles.splice(i, 1);
                } else {
                    particle.position.add(particle.userData.velocity);
                    const lifePercent = particle.userData.lifespan / particle.userData.initialLifespan;
                    particle.scale.setScalar(lifePercent * flameIntensity * particle.userData.initialSize);
                }
            }
            for (let i = activeSmokeParticles.length - 1; i >= 0; i--) {
                const particle = activeSmokeParticles[i];
                particle.userData.lifespan -= deltaTime;
                if (particle.userData.lifespan <= 0) {
                    particle.visible = false;
                    activeSmokeParticles.splice(i, 1);
                } else {
                    particle.position.add(particle.userData.velocity);
                    particle.material.opacity = (particle.userData.lifespan / (1.0 + 0.5)) * 0.5;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>


